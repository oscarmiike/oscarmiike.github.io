\chapter{README}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44}{}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44}\index{README@{README}}
\href{https://tools.ietf.org/html/rfc6265}{\texttt{ RFC6265}} Cookies and Cookie\+Jar for Node.\+js

\href{https://nodei.co/npm/tough-cookie/}{\texttt{ }}

\href{https://travis-ci.org/salesforce/tough-cookie}{\texttt{ }}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11711}{}\doxysection{\texorpdfstring{Synopsis}{Synopsis}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11711}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ javascript}
\DoxyCodeLine{var\ tough\ =\ require('tough-\/cookie');}
\DoxyCodeLine{var\ Cookie\ =\ tough.Cookie;}
\DoxyCodeLine{var\ cookie\ =\ Cookie.parse(header);}
\DoxyCodeLine{cookie.value\ =\ 'somethingdifferent';}
\DoxyCodeLine{header\ =\ cookie.toString();}
\DoxyCodeLine{}
\DoxyCodeLine{var\ cookiejar\ =\ new\ tough.CookieJar();}
\DoxyCodeLine{cookiejar.setCookie(cookie,\ 'http://currentdomain.example.com/path',\ cb);}
\DoxyCodeLine{//\ ...}
\DoxyCodeLine{cookiejar.getCookies('http://example.com/otherpath',function(err,cookies)\ \{}
\DoxyCodeLine{\ \ res.headers['cookie']\ =\ cookies.join(';\ ');}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11712}{}\doxysection{\texorpdfstring{Installation}{Installation}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11712}
It\textquotesingle{}s {\itshape so} easy!

{\ttfamily npm install tough-\/cookie}

Why the name? NPM modules {\ttfamily cookie}, {\ttfamily cookies} and {\ttfamily cookiejar} were already taken.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11713}{}\doxysubsection{\texorpdfstring{Version Support}{Version Support}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11713}
Support for versions of node.\+js will follow that of the \href{https://www.npmjs.com/package/request}{\texttt{ request}} module.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11714}{}\doxysection{\texorpdfstring{API}{API}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11714}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11715}{}\doxysubsection{\texorpdfstring{tough}{tough}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11715}
Functions on the module you get from `require(\textquotesingle{}tough-\/cookie')\`{}. All can be used as pure functions and don\textquotesingle{}t need to be "{}bound"{}.

{\bfseries{Note}}\+: prior to 1.\+0.\+x, several of these functions took a {\ttfamily strict} parameter. This has since been removed from the API as it was no longer necessary.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11716}{}\doxysubsubsection{\texorpdfstring{{\ttfamily parse\+Date(string)}}{{\ttfamily parse\+Date(string)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11716}
Parse a cookie date string into a {\ttfamily Date}. Parses according to RFC6265 Section 5.\+1.\+1, not {\ttfamily Date.\+parse()}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11717}{}\doxysubsubsection{\texorpdfstring{{\ttfamily format\+Date(date)}}{{\ttfamily format\+Date(date)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11717}
Format a Date into a RFC1123 string (the RFC6265-\/recommended format).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11718}{}\doxysubsubsection{\texorpdfstring{{\ttfamily canonical\+Domain(str)}}{{\ttfamily canonical\+Domain(str)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11718}
Transforms a domain-\/name into a canonical domain-\/name. The canonical domain-\/name is a trimmed, lowercased, stripped-\/of-\/leading-\/dot and optionally punycode-\/encoded domain-\/name (Section 5.\+1.\+2 of RFC6265). For the most part, this function is idempotent (can be run again on its output without ill effects).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11719}{}\doxysubsubsection{\texorpdfstring{{\ttfamily domain\+Match(str,dom\+Str\mbox{[},canonicalize=true\mbox{]})}}{{\ttfamily domain\+Match(str,dom\+Str\mbox{[},canonicalize=true\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11719}
Answers "{}does this real domain match the domain in a cookie?"{}. The {\ttfamily str} is the "{}current"{} domain-\/name and the {\ttfamily dom\+Str} is the "{}cookie"{} domain-\/name. Matches according to RFC6265 Section 5.\+1.\+3, but it helps to think of it as a "{}suffix match"{}.

The {\ttfamily canonicalize} parameter will run the other two parameters through {\ttfamily canonical\+Domain} or not.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11720}{}\doxysubsubsection{\texorpdfstring{{\ttfamily default\+Path(path)}}{{\ttfamily default\+Path(path)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11720}
Given a current request/response path, gives the Path apropriate for storing in a cookie. This is basically the "{}directory"{} of a "{}file"{} in the path, but is specified by Section 5.\+1.\+4 of the RFC.

The {\ttfamily path} parameter MUST be {\itshape only} the pathname part of a URI (i.\+e. excludes the hostname, query, fragment, etc.). This is the {\ttfamily .pathname} property of node\textquotesingle{}s {\ttfamily uri.\+parse()} output.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11721}{}\doxysubsubsection{\texorpdfstring{{\ttfamily path\+Match(req\+Path,cookie\+Path)}}{{\ttfamily path\+Match(req\+Path,cookie\+Path)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11721}
Answers "{}does the request-\/path path-\/match a given cookie-\/path?"{} as per RFC6265 Section 5.\+1.\+4. Returns a boolean.

This is essentially a prefix-\/match where {\ttfamily cookie\+Path} is a prefix of {\ttfamily req\+Path}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11722}{}\doxysubsubsection{\texorpdfstring{{\ttfamily parse(cookie\+String\mbox{[}, options\mbox{]})}}{{\ttfamily parse(cookie\+String\mbox{[}, options\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11722}
alias for {\ttfamily Cookie.\+parse(cookie\+String\mbox{[}, options\mbox{]})}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11723}{}\doxysubsubsection{\texorpdfstring{{\ttfamily from\+JSON(string)}}{{\ttfamily from\+JSON(string)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11723}
alias for {\ttfamily Cookie.\+from\+JSON(string)}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11724}{}\doxysubsubsection{\texorpdfstring{{\ttfamily get\+Public\+Suffix(hostname)}}{{\ttfamily get\+Public\+Suffix(hostname)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11724}
Returns the public suffix of this hostname. The public suffix is the shortest domain-\/name upon which a cookie can be set. Returns {\ttfamily null} if the hostname cannot have cookies set for it.

For example\+: {\ttfamily www.\+example.\+com} and {\ttfamily www.\+subdomain.\+example.\+com} both have public suffix {\ttfamily example.\+com}.

For further information, see \href{http://publicsuffix.org/}{\texttt{ http\+://publicsuffix.\+org/}}. This module derives its list from that site. This call is currently a wrapper around \href{https://www.npmjs.com/package/psl}{\texttt{ {\ttfamily psl}}}\textquotesingle{}s \href{https://www.npmjs.com/package/psl\#pslgetdomain}{\texttt{ get() method}}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11725}{}\doxysubsubsection{\texorpdfstring{{\ttfamily cookie\+Compare(a,b)}}{{\ttfamily cookie\+Compare(a,b)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11725}
For use with {\ttfamily .sort()}, sorts a list of cookies into the recommended order given in the RFC (Section 5.\+4 step 2). The sort algorithm is, in order of precedence\+:


\begin{DoxyItemize}
\item Longest {\ttfamily .path}
\item oldest {\ttfamily .creation} (which has a 1ms precision, same as {\ttfamily Date})
\item lowest {\ttfamily .creation\+Index} (to get beyond the 1ms precision)
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\ javascript}
\DoxyCodeLine{var\ cookies\ =\ [\ /*\ unsorted\ array\ of\ Cookie\ objects\ */\ ];}
\DoxyCodeLine{cookies\ =\ cookies.sort(cookieCompare);}

\end{DoxyCode}


{\bfseries{Note}}\+: Since Java\+Script\textquotesingle{}s {\ttfamily Date} is limited to a 1ms precision, cookies within the same milisecond are entirely possible. This is especially true when using the {\ttfamily now} option to {\ttfamily .set\+Cookie()}. The {\ttfamily .creation\+Index} property is a per-\/process global counter, assigned during construction with {\ttfamily new Cookie()}. This preserves the spirit of the RFC sorting\+: older cookies go first. This works great for {\ttfamily Memory\+Cookie\+Store}, since {\ttfamily Set-\/\+Cookie} headers are parsed in order, but may not be so great for distributed systems. Sophisticated {\ttfamily Store}s may wish to set this to some other {\itshape logical clock} such that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then {\ttfamily A.\+creation\+Index \texorpdfstring{$<$}{<} B.\+creation\+Index}. If you want to alter the global counter, which you probably {\itshape shouldn\textquotesingle{}t} do, it\textquotesingle{}s stored in {\ttfamily Cookie.\+cookies\+Created}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11726}{}\doxysubsubsection{\texorpdfstring{{\ttfamily permute\+Domain(domain)}}{{\ttfamily permute\+Domain(domain)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11726}
Generates a list of all possible domains that {\ttfamily domain\+Match()} the parameter. May be handy for implementing cookie stores.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11727}{}\doxysubsubsection{\texorpdfstring{{\ttfamily permute\+Path(path)}}{{\ttfamily permute\+Path(path)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11727}
Generates a list of all possible paths that {\ttfamily path\+Match()} the parameter. May be handy for implementing cookie stores.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11728}{}\doxysubsection{\texorpdfstring{Cookie}{Cookie}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11728}
Exported via {\ttfamily tough.\+Cookie}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11729}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie.\+parse(cookie\+String\mbox{[}, options\mbox{]})}}{{\ttfamily Cookie.\+parse(cookie\+String\mbox{[}, options\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11729}
Parses a single Cookie or Set-\/\+Cookie HTTP header into a {\ttfamily Cookie} object. Returns {\ttfamily undefined} if the string can\textquotesingle{}t be parsed.

The options parameter is not required and currently has only one property\+:


\begin{DoxyItemize}
\item {\itshape loose} -\/ boolean -\/ if {\ttfamily true} enable parsing of key-\/less cookies like {\ttfamily =abc} and {\ttfamily =}, which are not RFC-\/compliant.
\end{DoxyItemize}

If options is not an object, it is ignored, which means you can use {\ttfamily Array\#map} with it.

Here\textquotesingle{}s how to process the Set-\/\+Cookie header(s) on a node HTTP/\+HTTPS response\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ javascript}
\DoxyCodeLine{if\ (res.headers['set-\/cookie']\ instanceof\ Array)}
\DoxyCodeLine{\ \ cookies\ =\ res.headers['set-\/cookie'].map(Cookie.parse);}
\DoxyCodeLine{else}
\DoxyCodeLine{\ \ cookies\ =\ [Cookie.parse(res.headers['set-\/cookie'])];}

\end{DoxyCode}


{\itshape Note\+:} in version 2.\+3.\+3, tough-\/cookie limited the number of spaces before the {\ttfamily =} to 256 characters. This limitation has since been removed. See \href{https://github.com/salesforce/tough-cookie/issues/92}{\texttt{ Issue 92}}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11730}{}\doxysubsubsection{\texorpdfstring{Properties}{Properties}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11730}
Cookie object properties\+:


\begin{DoxyItemize}
\item {\itshape key} -\/ string -\/ the name or key of the cookie (default "{}"{})
\item {\itshape value} -\/ string -\/ the value of the cookie (default "{}"{})
\item {\itshape expires} -\/ {\ttfamily Date} -\/ if set, the {\ttfamily Expires=} attribute of the cookie (defaults to the string {\ttfamily "{}\+Infinity"{}}). See {\ttfamily set\+Expires()}
\item {\itshape max\+Age} -\/ seconds -\/ if set, the {\ttfamily Max-\/\+Age=} attribute {\itshape in seconds} of the cookie. May also be set to strings {\ttfamily "{}\+Infinity"{}} and {\ttfamily "{}-\/\+Infinity"{}} for non-\/expiry and immediate-\/expiry, respectively. See {\ttfamily set\+Max\+Age()}
\item {\itshape domain} -\/ string -\/ the {\ttfamily Domain=} attribute of the cookie
\item {\itshape path} -\/ string -\/ the {\ttfamily Path=} of the cookie
\item {\itshape secure} -\/ boolean -\/ the {\ttfamily Secure} cookie flag
\item {\itshape http\+Only} -\/ boolean -\/ the {\ttfamily Http\+Only} cookie flag
\item {\itshape extensions} -\/ {\ttfamily Array} -\/ any unrecognized cookie attributes as strings (even if equal-\/signs inside)
\item {\itshape creation} -\/ {\ttfamily Date} -\/ when this cookie was constructed
\item {\itshape creation\+Index} -\/ number -\/ set at construction, used to provide greater sort precision (please see {\ttfamily cookie\+Compare(a,b)} for a full explanation)
\end{DoxyItemize}

After a cookie has been passed through {\ttfamily Cookie\+Jar.\+set\+Cookie()} it will have the following additional attributes\+:


\begin{DoxyItemize}
\item {\itshape host\+Only} -\/ boolean -\/ is this a host-\/only cookie (i.\+e. no Domain field was set, but was instead implied)
\item {\itshape path\+Is\+Default} -\/ boolean -\/ if true, there was no Path field on the cookie and {\ttfamily default\+Path()} was used to derive one.
\item {\itshape creation} -\/ {\ttfamily Date} -\/ {\bfseries{modified}} from construction to when the cookie was added to the jar
\item {\itshape last\+Accessed} -\/ {\ttfamily Date} -\/ last time the cookie got accessed. Will affect cookie cleaning once implemented. Using {\ttfamily cookiejar.\+get\+Cookies(...)} will update this attribute.
\end{DoxyItemize}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11731}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie(\mbox{[}\{properties\}\mbox{]})}}{{\ttfamily Cookie(\mbox{[}\{properties\}\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11731}
Receives an options object that can contain any of the above Cookie properties, uses the default for unspecified properties.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11732}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .to\+String()}}{{\ttfamily .to\+String()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11732}
encode to a Set-\/\+Cookie header value. The Expires cookie field is set using {\ttfamily format\+Date()}, but is omitted entirely if {\ttfamily .expires} is {\ttfamily Infinity}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11733}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .cookie\+String()}}{{\ttfamily .cookie\+String()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11733}
encode to a Cookie header value (i.\+e. the {\ttfamily .key} and {\ttfamily .value} properties joined with \textquotesingle{}=\textquotesingle{}).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11734}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .set\+Expires(\+String)}}{{\ttfamily .set\+Expires(\+String)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11734}
sets the expiry based on a date-\/string passed through {\ttfamily parse\+Date()}. If parse\+Date returns {\ttfamily null} (i.\+e. can\textquotesingle{}t parse this date string), {\ttfamily .expires} is set to {\ttfamily "{}\+Infinity"{}} (a string) is set.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11735}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .set\+Max\+Age(number)}}{{\ttfamily .set\+Max\+Age(number)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11735}
sets the max\+Age in seconds. Coerces {\ttfamily -\/Infinity} to {\ttfamily "{}-\/\+Infinity"{}} and {\ttfamily Infinity} to {\ttfamily "{}\+Infinity"{}} so it JSON serializes correctly.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11736}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .expiry\+Time(\mbox{[}now=Date.\+now()\mbox{]})}}{{\ttfamily .expiry\+Time(\mbox{[}now=Date.\+now()\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11736}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11737}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .expiry\+Date(\mbox{[}now=Date.\+now()\mbox{]})}}{{\ttfamily .expiry\+Date(\mbox{[}now=Date.\+now()\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11737}
expiry\+Time() Computes the absolute unix-\/epoch milliseconds that this cookie expires. expiry\+Date() works similarly, except it returns a {\ttfamily Date} object. Note that in both cases the {\ttfamily now} parameter should be milliseconds.

Max-\/\+Age takes precedence over Expires (as per the RFC). The {\ttfamily .creation} attribute -- or, by default, the {\ttfamily now} parameter -- is used to offset the {\ttfamily .max\+Age} attribute.

If Expires ({\ttfamily .expires}) is set, that\textquotesingle{}s returned.

Otherwise, {\ttfamily expiry\+Time()} returns {\ttfamily Infinity} and {\ttfamily expiry\+Date()} returns a {\ttfamily Date} object for "{}\+Tue, 19 Jan 2038 03\+:14\+:07 GMT"{} (latest date that can be expressed by a 32-\/bit {\ttfamily time\+\_\+t}; the common limit for most user-\/agents).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11738}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .TTL(\mbox{[}now=Date.\+now()\mbox{]})}}{{\ttfamily .TTL(\mbox{[}now=Date.\+now()\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11738}
compute the TTL relative to {\ttfamily now} (milliseconds). The same precedence rules as for {\ttfamily expiry\+Time}/{\ttfamily expiry\+Date} apply.

The "{}number"{} {\ttfamily Infinity} is returned for cookies without an explicit expiry and {\ttfamily 0} is returned if the cookie is expired. Otherwise a time-\/to-\/live in milliseconds is returned.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11739}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .canonicalized\+Domain()}}{{\ttfamily .canonicalized\+Domain()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11739}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11740}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .cdomain()}}{{\ttfamily .cdomain()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11740}
return the canonicalized {\ttfamily .domain} field. This is lower-\/cased and punycode (RFC3490) encoded if the domain has any non-\/\+ASCII characters.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11741}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .to\+JSON()}}{{\ttfamily .to\+JSON()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11741}
For convenience in using {\ttfamily JSON.\+serialize(cookie)}. Returns a plain-\/old {\ttfamily Object} that can be JSON-\/serialized.

Any {\ttfamily Date} properties (i.\+e., {\ttfamily .expires}, {\ttfamily .creation}, and {\ttfamily .last\+Accessed}) are exported in ISO format ({\ttfamily .to\+ISOString()}).

{\bfseries{NOTE}}\+: Custom {\ttfamily Cookie} properties will be discarded. In tough-\/cookie 1.\+x, since there was no {\ttfamily .to\+JSON} method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the {\ttfamily Cookie.\+serializable\+Properties} Array.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11742}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie.\+from\+JSON(str\+Or\+Obj)}}{{\ttfamily Cookie.\+from\+JSON(str\+Or\+Obj)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11742}
Does the reverse of {\ttfamily cookie.\+to\+JSON()}. If passed a string, will {\ttfamily JSON.\+parse()} that first.

Any {\ttfamily Date} properties (i.\+e., {\ttfamily .expires}, {\ttfamily .creation}, and {\ttfamily .last\+Accessed}) are parsed via {\ttfamily Date.\+parse()}, not the tough-\/cookie {\ttfamily parse\+Date}, since it\textquotesingle{}s Java\+Script/\+JSON-\/y timestamps being handled at this layer.

Returns {\ttfamily null} upon JSON parsing error.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11743}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .clone()}}{{\ttfamily .clone()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11743}
Does a deep clone of this cookie, exactly implemented as {\ttfamily Cookie.\+from\+JSON(cookie.\+to\+JSON())}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11744}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .validate()}}{{\ttfamily .validate()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11744}
Status\+: {\itshape IN PROGRESS}. Works for a few things, but is by no means comprehensive.

validates cookie attributes for semantic correctness. Useful for "{}lint"{} checking any Set-\/\+Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string -- you can future-\/proof with this construct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ javascript}
\DoxyCodeLine{if\ (cookie.validate()\ ===\ true)\ \{}
\DoxyCodeLine{\ \ //\ it's\ tasty}
\DoxyCodeLine{\}\ else\ \{}
\DoxyCodeLine{\ \ //\ yuck!}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11745}{}\doxysubsection{\texorpdfstring{Cookie\+Jar}{Cookie\+Jar}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11745}
Exported via {\ttfamily tough.\+Cookie\+Jar}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11746}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie\+Jar(\mbox{[}store\mbox{]},\mbox{[}options\mbox{]})}}{{\ttfamily Cookie\+Jar(\mbox{[}store\mbox{]},\mbox{[}options\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11746}
Simply use {\ttfamily new Cookie\+Jar()}. If you\textquotesingle{}d like to use a custom store, pass that to the constructor otherwise a {\ttfamily Memory\+Cookie\+Store} will be created and used.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape reject\+Public\+Suffixes} -\/ boolean -\/ default {\ttfamily true} -\/ reject cookies with domains like "{}com"{} and "{}co.\+uk"{}
\item {\itshape loose\+Mode} -\/ boolean -\/ default {\ttfamily false} -\/ accept malformed cookies like {\ttfamily bar} and {\ttfamily =bar}, which have an implied empty name. This is not in the standard, but is used sometimes on the web and is accepted by (most) browsers.
\end{DoxyItemize}

Since eventually this module would like to support database/remote/etc. Cookie\+Jars, continuation passing style is used for Cookie\+Jar methods.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11747}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .set\+Cookie(cookie\+Or\+String, current\+Url, \mbox{[}\{options\},\mbox{]} cb(err,cookie))}}{{\ttfamily .set\+Cookie(cookie\+Or\+String, current\+Url, \mbox{[}\{options\},\mbox{]} cb(err,cookie))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11747}
Attempt to set the cookie in the cookie jar. If the operation fails, an error will be given to the callback {\ttfamily cb}, otherwise the cookie is passed through. The cookie will have updated {\ttfamily .creation}, {\ttfamily .last\+Accessed} and {\ttfamily .host\+Only} properties.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape http} -\/ boolean -\/ default {\ttfamily true} -\/ indicates if this is an HTTP or non-\/\+HTTP API. Affects Http\+Only cookies.
\item {\itshape secure} -\/ boolean -\/ autodetect from url -\/ indicates if this is a "{}\+Secure"{} API. If the current\+Url starts with {\ttfamily https\+:} or {\ttfamily wss\+:} then this is defaulted to {\ttfamily true}, otherwise {\ttfamily false}.
\item {\itshape now} -\/ Date -\/ default {\ttfamily new Date()} -\/ what to use for the creation/access time of cookies
\item {\itshape ignore\+Error} -\/ boolean -\/ default {\ttfamily false} -\/ silently ignore things like parse errors and invalid domains. {\ttfamily Store} errors aren\textquotesingle{}t ignored by this option.
\end{DoxyItemize}

As per the RFC, the {\ttfamily .host\+Only} property is set if there was no "{}\+Domain="{} parameter in the cookie string (or {\ttfamily .domain} was null on the Cookie object). The {\ttfamily .domain} property is set to the fully-\/qualified hostname of {\ttfamily current\+Url} in this case. Matching this cookie requires an exact hostname match (not a {\ttfamily domain\+Match} as per usual).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11748}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .set\+Cookie\+Sync(cookie\+Or\+String, current\+Url, \mbox{[}\{options\}\mbox{]})}}{{\ttfamily .set\+Cookie\+Sync(cookie\+Or\+String, current\+Url, \mbox{[}\{options\}\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11748}
Synchronous version of {\ttfamily set\+Cookie}; only works with synchronous stores (e.\+g. the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11749}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Cookies(current\+Url, \mbox{[}\{options\},\mbox{]} cb(err,cookies))}}{{\ttfamily .get\+Cookies(current\+Url, \mbox{[}\{options\},\mbox{]} cb(err,cookies))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11749}
Retrieve the list of cookies that can be sent in a Cookie header for the current url.

If an error is encountered, that\textquotesingle{}s passed as {\ttfamily err} to the callback, otherwise an {\ttfamily Array} of {\ttfamily Cookie} objects is passed. The array is sorted with {\ttfamily cookie\+Compare()} unless the {\ttfamily \{sort\+:false\}} option is given.

The {\ttfamily options} object can be omitted and can have the following properties\+:


\begin{DoxyItemize}
\item {\itshape http} -\/ boolean -\/ default {\ttfamily true} -\/ indicates if this is an HTTP or non-\/\+HTTP API. Affects Http\+Only cookies.
\item {\itshape secure} -\/ boolean -\/ autodetect from url -\/ indicates if this is a "{}\+Secure"{} API. If the current\+Url starts with {\ttfamily https\+:} or {\ttfamily wss\+:} then this is defaulted to {\ttfamily true}, otherwise {\ttfamily false}.
\item {\itshape now} -\/ Date -\/ default {\ttfamily new Date()} -\/ what to use for the creation/access time of cookies
\item {\itshape expire} -\/ boolean -\/ default {\ttfamily true} -\/ perform expiry-\/time checking of cookies and asynchronously remove expired cookies from the store. Using {\ttfamily false} will return expired cookies and {\bfseries{not}} remove them from the store (which is useful for replaying Set-\/\+Cookie headers, potentially).
\item {\itshape all\+Paths} -\/ boolean -\/ default {\ttfamily false} -\/ if {\ttfamily true}, do not scope cookies by path. The default uses RFC-\/compliant path scoping. {\bfseries{Note}}\+: may not be supported by the underlying store (the default {\ttfamily Memory\+Cookie\+Store} supports it).
\end{DoxyItemize}

The {\ttfamily .last\+Accessed} property of the returned cookies will have been updated.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11750}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Cookies\+Sync(current\+Url, \mbox{[}\{options\}\mbox{]})}}{{\ttfamily .get\+Cookies\+Sync(current\+Url, \mbox{[}\{options\}\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11750}
Synchronous version of {\ttfamily get\+Cookies}; only works with synchronous stores (e.\+g. the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11751}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Cookie\+String(...)}}{{\ttfamily .get\+Cookie\+String(...)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11751}
Accepts the same options as {\ttfamily .get\+Cookies()} but passes a string suitable for a Cookie header rather than an array to the callback. Simply maps the {\ttfamily Cookie} array via {\ttfamily .cookie\+String()}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11752}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Cookie\+String\+Sync(...)}}{{\ttfamily .get\+Cookie\+String\+Sync(...)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11752}
Synchronous version of {\ttfamily get\+Cookie\+String}; only works with synchronous stores (e.\+g. the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11753}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Set\+Cookie\+Strings(...)}}{{\ttfamily .get\+Set\+Cookie\+Strings(...)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11753}
Returns an array of strings suitable for {\bfseries{Set-\/\+Cookie}} headers. Accepts the same options as {\ttfamily .get\+Cookies()}. Simply maps the cookie array via {\ttfamily .to\+String()}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11754}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .get\+Set\+Cookie\+Strings\+Sync(...)}}{{\ttfamily .get\+Set\+Cookie\+Strings\+Sync(...)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11754}
Synchronous version of {\ttfamily get\+Set\+Cookie\+Strings}; only works with synchronous stores (e.\+g. the default {\ttfamily Memory\+Cookie\+Store}).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11755}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .serialize(cb(err,serialized\+Object))}}{{\ttfamily .serialize(cb(err,serialized\+Object))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11755}
Serialize the Jar if the underlying store supports {\ttfamily .get\+All\+Cookies}.

{\bfseries{NOTE}}\+: Custom {\ttfamily Cookie} properties will be discarded. If you want a property to be serialized, add the property name to the {\ttfamily Cookie.\+serializable\+Properties} Array.

See \mbox{[}Serialization Format\mbox{]}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11756}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .serialize\+Sync()}}{{\ttfamily .serialize\+Sync()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11756}
Sync version of .serialize\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11757}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .to\+JSON()}}{{\ttfamily .to\+JSON()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11757}
Alias of .serialize\+Sync() for the convenience of {\ttfamily JSON.\+stringify(cookiejar)}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11758}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie\+Jar.\+deserialize(serialized, \mbox{[}store\mbox{]}, cb(err,object))}}{{\ttfamily Cookie\+Jar.\+deserialize(serialized, \mbox{[}store\mbox{]}, cb(err,object))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11758}
A new Jar is created and the serialized Cookies are added to the underlying store. Each {\ttfamily Cookie} is added via {\ttfamily store.\+put\+Cookie} in the order in which they appear in the serialization.

The {\ttfamily store} argument is optional, but should be an instance of {\ttfamily Store}. By default, a new instance of {\ttfamily Memory\+Cookie\+Store} is created.

As a convenience, if {\ttfamily serialized} is a string, it is passed through {\ttfamily JSON.\+parse} first. If that throws an error, this is passed to the callback.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11759}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie\+Jar.\+deserialize\+Sync(serialized, \mbox{[}store\mbox{]})}}{{\ttfamily Cookie\+Jar.\+deserialize\+Sync(serialized, \mbox{[}store\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11759}
Sync version of {\ttfamily .deserialize}. {\itshape Note} that the {\ttfamily store} must be synchronous for this to work.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11760}{}\doxysubsubsection{\texorpdfstring{{\ttfamily Cookie\+Jar.\+from\+JSON(string)}}{{\ttfamily Cookie\+Jar.\+from\+JSON(string)}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11760}
Alias of {\ttfamily .deserialize\+Sync} to provide consistency with {\ttfamily Cookie.\+from\+JSON()}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11761}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .clone(\mbox{[}store,\mbox{]}cb(err,new\+Jar))}}{{\ttfamily .clone(\mbox{[}store,\mbox{]}cb(err,new\+Jar))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11761}
Produces a deep clone of this jar. Modifications to the original won\textquotesingle{}t affect the clone, and vice versa.

The {\ttfamily store} argument is optional, but should be an instance of {\ttfamily Store}. By default, a new instance of {\ttfamily Memory\+Cookie\+Store} is created. Transferring between store types is supported so long as the source implements {\ttfamily .get\+All\+Cookies()} and the destination implements {\ttfamily .put\+Cookie()}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11762}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .clone\+Sync(\mbox{[}store\mbox{]})}}{{\ttfamily .clone\+Sync(\mbox{[}store\mbox{]})}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11762}
Synchronous version of {\ttfamily .clone}, returning a new {\ttfamily Cookie\+Jar} instance.

The {\ttfamily store} argument is optional, but must be a {\itshape synchronous} {\ttfamily Store} instance if specified. If not passed, a new instance of {\ttfamily Memory\+Cookie\+Store} is used.

The {\itshape source} and {\itshape destination} must both be synchronous {\ttfamily Store}s. If one or both stores are asynchronous, use {\ttfamily .clone} instead. Recall that {\ttfamily Memory\+Cookie\+Store} supports both synchronous and asynchronous API calls.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11763}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .remove\+All\+Cookies(cb(err))}}{{\ttfamily .remove\+All\+Cookies(cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11763}
Removes all cookies from the jar.

This is a new backwards-\/compatible feature of {\ttfamily tough-\/cookie} version 2.\+5, so not all Stores will implement it efficiently. For Stores that do not implement {\ttfamily remove\+All\+Cookies}, the fallback is to call {\ttfamily remove\+Cookie} after {\ttfamily get\+All\+Cookies}. If {\ttfamily get\+All\+Cookies} fails or isn\textquotesingle{}t implemented in the Store, that error is returned. If one or more of the {\ttfamily remove\+Cookie} calls fail, only the first error is returned.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11764}{}\doxysubsubsection{\texorpdfstring{{\ttfamily .remove\+All\+Cookies\+Sync()}}{{\ttfamily .remove\+All\+Cookies\+Sync()}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11764}
Sync version of {\ttfamily .remove\+All\+Cookies()}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11765}{}\doxysubsection{\texorpdfstring{Store}{Store}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11765}
Base class for Cookie\+Jar stores. Available as {\ttfamily tough.\+Store}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11766}{}\doxysubsection{\texorpdfstring{Store API}{Store API}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11766}
The storage model for each {\ttfamily Cookie\+Jar} instance can be replaced with a custom implementation. The default is {\ttfamily Memory\+Cookie\+Store} which can be found in the {\ttfamily lib/memstore.\+js} file. The API uses continuation-\/passing-\/style to allow for asynchronous stores.

Stores should inherit from the base {\ttfamily Store} class, which is available as `require(\textquotesingle{}tough-\/cookie').Store\`{}.

Stores are asynchronous by default, but if {\ttfamily store.\+synchronous} is set to {\ttfamily true}, then the {\ttfamily \texorpdfstring{$\ast$}{*}\+Sync} methods on the of the containing {\ttfamily Cookie\+Jar} can be used (however, the continuation-\/passing style

All {\ttfamily domain} parameters will have been normalized before calling.

The Cookie store must have all of the following methods.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11767}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+find\+Cookie(domain, path, key, cb(err,cookie))}}{{\ttfamily store.\+find\+Cookie(domain, path, key, cb(err,cookie))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11767}
Retrieve a cookie with the given domain, path and key (a.\+k.\+a. name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest/newest such cookie should be returned.

Callback takes an error and the resulting {\ttfamily Cookie} object. If no cookie is found then {\ttfamily null} MUST be passed instead (i.\+e. not an error).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11768}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+find\+Cookies(domain, path, cb(err,cookies))}}{{\ttfamily store.\+find\+Cookies(domain, path, cb(err,cookies))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11768}
Locates cookies matching the given domain and path. This is most often called in the context of {\ttfamily cookiejar.\+get\+Cookies()} above.

If no cookies are found, the callback MUST be passed an empty array.

The resulting list will be checked for applicability to the current request according to the RFC (domain-\/match, path-\/match, http-\/only-\/flag, secure-\/flag, expiry, etc.), so it\textquotesingle{}s OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that {\ttfamily domain\+Match()} the domain and {\ttfamily path\+Match()} the path in order to limit the amount of checking that needs to be done.

As of version 0.\+9.\+12, the {\ttfamily all\+Paths} option to {\ttfamily cookiejar.\+get\+Cookies()} above will cause the path here to be {\ttfamily null}. If the path is {\ttfamily null}, path-\/matching MUST NOT be performed (i.\+e. domain-\/matching only).\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11769}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+put\+Cookie(cookie, cb(err))}}{{\ttfamily store.\+put\+Cookie(cookie, cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11769}
Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same {\ttfamily .domain}, {\ttfamily .path}, and {\ttfamily .key} properties -- depending on the nature of the implementation, it\textquotesingle{}s possible that between the call to {\ttfamily fetch\+Cookie} and {\ttfamily put\+Cookie} that a duplicate {\ttfamily put\+Cookie} can occur.

The {\ttfamily cookie} object MUST NOT be modified; the caller will have already updated the {\ttfamily .creation} and {\ttfamily .last\+Accessed} properties.

Pass an error if the cookie cannot be stored.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11770}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+update\+Cookie(old\+Cookie, new\+Cookie, cb(err))}}{{\ttfamily store.\+update\+Cookie(old\+Cookie, new\+Cookie, cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11770}
Update an existing cookie. The implementation MUST update the {\ttfamily .value} for a cookie with the same {\ttfamily domain}, {\ttfamily .path} and {\ttfamily .key}. The implementation SHOULD check that the old value in the store is equivalent to {\ttfamily old\+Cookie} -\/ how the conflict is resolved is up to the store.

The {\ttfamily .last\+Accessed} property will always be different between the two objects (to the precision possible via Java\+Script\textquotesingle{}s clock). Both {\ttfamily .creation} and {\ttfamily .creation\+Index} are guaranteed to be the same. Stores MAY ignore or defer the {\ttfamily .last\+Accessed} change at the cost of affecting how cookies are selected for automatic deletion (e.\+g., least-\/recently-\/used, which is up to the store to implement).

Stores may wish to optimize changing the {\ttfamily .value} of the cookie in the store versus storing a new cookie. If the implementation doesn\textquotesingle{}t define this method a stub that calls {\ttfamily put\+Cookie(new\+Cookie,cb)} will be added to the store object.

The {\ttfamily new\+Cookie} and {\ttfamily old\+Cookie} objects MUST NOT be modified.

Pass an error if the new\+Cookie cannot be stored.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11771}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+remove\+Cookie(domain, path, key, cb(err))}}{{\ttfamily store.\+remove\+Cookie(domain, path, key, cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11771}
Remove a cookie from the store (see notes on {\ttfamily find\+Cookie} about the uniqueness constraint).

The implementation MUST NOT pass an error if the cookie doesn\textquotesingle{}t exist; only pass an error due to the failure to remove an existing cookie.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11772}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+remove\+Cookies(domain, path, cb(err))}}{{\ttfamily store.\+remove\+Cookies(domain, path, cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11772}
Removes matching cookies from the store. The {\ttfamily path} parameter is optional, and if missing means all paths in a domain should be removed.

Pass an error ONLY if removing any existing cookies failed.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11773}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+remove\+All\+Cookies(cb(err))}}{{\ttfamily store.\+remove\+All\+Cookies(cb(err))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11773}
{\itshape Optional}. Removes all cookies from the store.

Pass an error if one or more cookies can\textquotesingle{}t be removed.

{\bfseries{Note}}\+: New method as of {\ttfamily tough-\/cookie} version 2.\+5, so not all Stores will implement this, plus some stores may choose not to implement this.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11774}{}\doxysubsubsection{\texorpdfstring{{\ttfamily store.\+get\+All\+Cookies(cb(err, cookies))}}{{\ttfamily store.\+get\+All\+Cookies(cb(err, cookies))}}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11774}
{\itshape Optional}. Produces an {\ttfamily Array} of all cookies during {\ttfamily jar.\+serialize()}. The items in the array can be true {\ttfamily Cookie} objects or generic {\ttfamily Object}s with the \mbox{[}Serialization Format\mbox{]} data structure.

Cookies SHOULD be returned in creation order to preserve sorting via {\ttfamily compare\+Cookies()}. For reference, {\ttfamily Memory\+Cookie\+Store} will sort by {\ttfamily .creation\+Index} since it uses true {\ttfamily Cookie} objects internally. If you don\textquotesingle{}t return the cookies in creation order, they\textquotesingle{}ll still be sorted by creation time, but this only has a precision of 1ms. See {\ttfamily compare\+Cookies} for more detail.

Pass an error if retrieval fails.

{\bfseries{Note}}\+: not all Stores can implement this due to technical limitations, so it is optional.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11775}{}\doxysubsection{\texorpdfstring{Memory\+Cookie\+Store}{Memory\+Cookie\+Store}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11775}
Inherits from {\ttfamily Store}.

A just-\/in-\/memory Cookie\+Jar synchronous store implementation, used by default. Despite being a synchronous implementation, it\textquotesingle{}s usable with both the synchronous and asynchronous forms of the {\ttfamily Cookie\+Jar} API. Supports serialization, {\ttfamily get\+All\+Cookies}, and {\ttfamily remove\+All\+Cookies}.\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11776}{}\doxysubsection{\texorpdfstring{Community Cookie Stores}{Community Cookie Stores}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11776}
These are some Store implementations authored and maintained by the community. They aren\textquotesingle{}t official and we don\textquotesingle{}t vouch for them but you may be interested to have a look\+:


\begin{DoxyItemize}
\item \href{https://github.com/JSBizon/db-cookie-store}{\texttt{ {\ttfamily db-\/cookie-\/store}}}\+: SQL including SQLite-\/based databases
\item \href{https://github.com/JSBizon/file-cookie-store}{\texttt{ {\ttfamily file-\/cookie-\/store}}}\+: Netscape cookie file format on disk
\item \href{https://github.com/benkroeger/redis-cookie-store}{\texttt{ {\ttfamily redis-\/cookie-\/store}}}\+: Redis
\item \href{https://github.com/mitsuru/tough-cookie-filestore}{\texttt{ {\ttfamily tough-\/cookie-\/filestore}}}\+: JSON on disk
\item \href{https://github.com/exponentjs/tough-cookie-web-storage-store}{\texttt{ {\ttfamily tough-\/cookie-\/web-\/storage-\/store}}}\+: DOM local\+Storage and session\+Storage
\end{DoxyItemize}\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11777}{}\doxysection{\texorpdfstring{Serialization Format}{Serialization Format}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11777}
{\bfseries{NOTE}}\+: if you want to have custom {\ttfamily Cookie} properties serialized, add the property name to {\ttfamily Cookie.\+serializable\+Properties}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ //\ The\ version\ of\ tough-\/cookie\ that\ serialized\ this\ jar.}
\DoxyCodeLine{\ \ version:\ 'tough-\/cookie@1.x.y',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ add\ the\ store\ type,\ to\ make\ humans\ happy:}
\DoxyCodeLine{\ \ storeType:\ 'MemoryCookieStore',}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ CookieJar\ configuration:}
\DoxyCodeLine{\ \ rejectPublicSuffixes:\ true,}
\DoxyCodeLine{\ \ //\ ...\ future\ items\ go\ here}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ Gets\ filled\ from\ jar.store.getAllCookies():}
\DoxyCodeLine{\ \ cookies:\ [}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ key:\ 'string',}
\DoxyCodeLine{\ \ \ \ \ \ value:\ 'string',}
\DoxyCodeLine{\ \ \ \ \ \ //\ ...}
\DoxyCodeLine{\ \ \ \ \ \ /*\ other\ Cookie.serializableProperties\ go\ here\ */}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ ]}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11778}{}\doxysection{\texorpdfstring{Copyright and License}{Copyright and License}}\label{md__c_1_2_users_2_s_t_r_i_d_e_r_2source_2repos_2_ainslie_a_p_i_2wwwroot_2lib_2jquery-ui_2node__mbb988c4288d16c43d424849845cb6a44_autotoc_md11778}
BSD-\/3-\/\+Clause\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Copyright\ (c)\ 2015,\ Salesforce.com,\ Inc.}
\DoxyCodeLine{All\ rights\ reserved.}
\DoxyCodeLine{}
\DoxyCodeLine{Redistribution\ and\ use\ in\ source\ and\ binary\ forms,\ with\ or\ without}
\DoxyCodeLine{modification,\ are\ permitted\ provided\ that\ the\ following\ conditions\ are\ met:}
\DoxyCodeLine{}
\DoxyCodeLine{1.\ Redistributions\ of\ source\ code\ must\ retain\ the\ above\ copyright\ notice,}
\DoxyCodeLine{this\ list\ of\ conditions\ and\ the\ following\ disclaimer.}
\DoxyCodeLine{}
\DoxyCodeLine{2.\ Redistributions\ in\ binary\ form\ must\ reproduce\ the\ above\ copyright\ notice,}
\DoxyCodeLine{this\ list\ of\ conditions\ and\ the\ following\ disclaimer\ in\ the\ documentation}
\DoxyCodeLine{and/or\ other\ materials\ provided\ with\ the\ distribution.}
\DoxyCodeLine{}
\DoxyCodeLine{3.\ Neither\ the\ name\ of\ Salesforce.com\ nor\ the\ names\ of\ its\ contributors\ may}
\DoxyCodeLine{be\ used\ to\ endorse\ or\ promote\ products\ derived\ from\ this\ software\ without}
\DoxyCodeLine{specific\ prior\ written\ permission.}
\DoxyCodeLine{}
\DoxyCodeLine{THIS\ SOFTWARE\ IS\ PROVIDED\ BY\ THE\ COPYRIGHT\ HOLDERS\ AND\ CONTRIBUTORS\ "{}AS\ IS"{}}
\DoxyCodeLine{AND\ ANY\ EXPRESS\ OR\ IMPLIED\ WARRANTIES,\ INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ THE}
\DoxyCodeLine{IMPLIED\ WARRANTIES\ OF\ MERCHANTABILITY\ AND\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE}
\DoxyCodeLine{ARE\ DISCLAIMED.\ IN\ NO\ EVENT\ SHALL\ THE\ COPYRIGHT\ HOLDER\ OR\ CONTRIBUTORS\ BE}
\DoxyCodeLine{LIABLE\ FOR\ ANY\ DIRECT,\ INDIRECT,\ INCIDENTAL,\ SPECIAL,\ EXEMPLARY,\ OR}
\DoxyCodeLine{CONSEQUENTIAL\ DAMAGES\ (INCLUDING,\ BUT\ NOT\ LIMITED\ TO,\ PROCUREMENT\ OF}
\DoxyCodeLine{SUBSTITUTE\ GOODS\ OR\ SERVICES;\ LOSS\ OF\ USE,\ DATA,\ OR\ PROFITS;\ OR\ BUSINESS}
\DoxyCodeLine{INTERRUPTION)\ HOWEVER\ CAUSED\ AND\ ON\ ANY\ THEORY\ OF\ LIABILITY,\ WHETHER\ IN}
\DoxyCodeLine{CONTRACT,\ STRICT\ LIABILITY,\ OR\ TORT\ (INCLUDING\ NEGLIGENCE\ OR\ OTHERWISE)}
\DoxyCodeLine{ARISING\ IN\ ANY\ WAY\ OUT\ OF\ THE\ USE\ OF\ THIS\ SOFTWARE,\ EVEN\ IF\ ADVISED\ OF\ THE}
\DoxyCodeLine{POSSIBILITY\ OF\ SUCH\ DAMAGE.}

\end{DoxyCode}
 