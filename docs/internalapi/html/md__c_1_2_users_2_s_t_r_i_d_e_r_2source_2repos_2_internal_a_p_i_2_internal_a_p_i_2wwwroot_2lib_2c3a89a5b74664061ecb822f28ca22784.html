<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>InternalAPI: CSS Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">InternalAPI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">CSS Parser</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md10634"></a> <a href="https://travis-ci.org/CSSLint/parser-lib"><img src="https://secure.travis-ci.org/CSSLint/parser-lib.svg?branch=master" alt="build status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md10635"></a>
Introduction</h1>
<p>The ParserLib CSS parser is a CSS3 SAX-inspired parser written in JavaScript. It handles standard CSS syntax as well as validation (checking of property names and values) although it is not guaranteed to thoroughly validate all possible CSS properties.</p>
<h1><a class="anchor" id="autotoc_md10636"></a>
Adding to your project</h1>
<p>The CSS parser is built for a number of different JavaScript environments. The most recently released version of the parser can be found in the <code>dist</code> directory when you check out the repository; run <code>npm run build</code> to regenerate them from the latest sources.</p>
<h2><a class="anchor" id="autotoc_md10637"></a>
Node.js</h2>
<p>You can use the CSS parser in a <code>Node.js</code> script via the standard <code>npm</code> package manager as the <code>parserlib</code> package (<code>npm install parserlib</code>):</p>
<div class="fragment"><div class="line">var parserlib = require(&quot;parserlib&quot;);</div>
<div class="line"> </div>
<div class="line">var parser = new parserlib.css.Parser();</div>
</div><!-- fragment --><p>Alternatively, you can copy a single file version of the parser from <code>dist/node-parserlib.js</code> to your own project, and use it as follows:</p>
<div class="fragment"><div class="line">var parserlib = require(&quot;./node-parserlib&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10638"></a>
Rhino</h2>
<p>To use the CSS parser in a Rhino script, copy the file <code>dist/parserlib.js</code> to your project and then include it at the beginning:</p>
<div class="fragment"><div class="line">load(&quot;parserlib.js&quot;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10639"></a>
HTML page</h2>
<p>To use the CSS parser on an HTML page, you can either include the entire library on your page:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;parserlib.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>Or include it as its component parts, the ParserLib core and the CSS parser:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;parserlib-core.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script src=&quot;parserlib-css.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>Note that parsing large JavaScript files may cause the browser to become unresponsive. All three of these files are located in the <code>dist</code> directory.</p>
<h1><a class="anchor" id="autotoc_md10640"></a>
Basic usage</h1>
<p>You can create a new instance of the parser by using the following code:</p>
<div class="fragment"><div class="line">var parser = new parserlib.css.Parser();</div>
</div><!-- fragment --><p>The constructor accepts an options object that specifies additional features the parser should use. The available options are:</p>
<ul>
<li><code>starHack</code> - set to true to treat properties with a leading asterisk as if the asterisk wasn't there. Default is <code>false</code>.</li>
<li><code>underscoreHack</code> - set to true to treat properties with a leading underscore as if the underscore wasn't there. Default is <code>false</code>.</li>
<li><code>ieFilters</code> - set to true to accept IE &lt; 8 style <code>filter</code> properties. Default is <code>false</code>.</li>
<li><code>strict</code> - set to true to disable error recovery and stop on the first syntax error. Default is <code>false</code>.</li>
</ul>
<p>Here's an example with some options set:</p>
<div class="fragment"><div class="line">var parser = new parserlib.css.Parser({ starHack: true, underscoreHack: true });</div>
</div><!-- fragment --><p>You can then parse a string of CSS code by passing into the <code>parse()</code> method:</p>
<div class="fragment"><div class="line">parser.parse(someCSSText);</div>
</div><!-- fragment --><p>The <code>parse()</code> method throws an error if a non-recoverable syntax error occurs, otherwise it finishes silently. This method does not return a value nor does it build up an abstract syntax tree (AST) for you, it simply parses the CSS text and fires events at important moments along the parse.</p>
<p>Note: The <code>parseStyleSheet()</code> method is provided for compatibility with SAC-based APIs but does the exact same thing as <code>parse()</code>.</p>
<h1><a class="anchor" id="autotoc_md10641"></a>
Understanding syntax units</h1>
<p>The CSS parser defines several types that inherit from <code>parserlib.util.SyntaxUnit</code>. These types are designed to give you easy access to all relevant parts of the CSS syntax.</p>
<h2><a class="anchor" id="autotoc_md10642"></a>
Media Queries</h2>
<p>The <code>parserlib.css.MediaFeature</code> type represents a specific media feature in a media query, such as <code>(orientation: portrait)</code> or <code>(color)</code>. Essentially, this type of object represents anything enclosed in parentheses in a media query. Object of this type have the following properties:</p>
<ul>
<li><code>name</code> - the name of the media feature such as "orientation"</li>
<li><code>value</code> - the value of the media feature (may be <code>null</code>)</li>
</ul>
<p>The <code>parserlib.css.MediaQuery</code> type represents all parts of a media query. Each instance has the following properties:</p>
<ul>
<li><code>modifier</code> - either "not" or "only"</li>
<li><code>mediaType</code> - the actual media type such as "print"</li>
<li><code>features</code> - an array of <code>parserlib.css.MediaFeature</code> objects</li>
</ul>
<p>For example, consider the following media query:</p>
<div class="fragment"><div class="line">only screen and (max-device-width: 768px) and (orientation: portrait)</div>
</div><!-- fragment --><p>A corresponding object would have the following values:</p>
<ul>
<li><code>modifier</code> = "only"</li>
<li><code>mediaType</code> = "screen"</li>
<li><code>features</code> = array of (<code>name</code>="max-device-width", <code>value</code>="768px") and (<code>name</code>="orientation", <code>value</code>="portrait")</li>
</ul>
<h2><a class="anchor" id="autotoc_md10643"></a>
Properties</h2>
<p>The <code>parserlib.css.PropertyName</code> type represents a property name. Each instance has the following properties:</p>
<ul>
<li><code>hack</code> - if star or underscore hacks are allowed, either <code>*</code> or <code>_</code> if present (<code>null</code> if not present or hacks are not allowed)</li>
</ul>
<p>When star hacks are allowed, the <code>text</code> property becomes the actual property name, so <code>*width</code> has <code>hack</code> equal to <code>*</code> and <code>text</code> equal to "width". If no hacks are allowed, then <code>*width</code> causes a syntax error while <code>_width</code> has <code>hack</code> equal to <code>null</code> and <code>text</code> equal to <code>_width</code>.</p>
<p>The <code>parserlib.css.PropertyValue</code> type represents a property value. Since property values in CSS are complex, this type of object wraps the various parts into a single interface. Each instance has the following properties:</p>
<ul>
<li><code>parts</code> - array of <code>PropertyValuePart</code> objects</li>
</ul>
<p>The <code>parts</code> array always has at least one item.</p>
<p>The <code>parserlib.css.PropertyValuePart</code> type represents an individual part of a property value. Each instance has the following properties:</p>
<ul>
<li><code>type</code> - the type of value part ("unknown", "dimension", "percentage", "integer", "number", "color", "uri", "string", "identifier" or "operator")</li>
</ul>
<p>A part is considered any atomic piece of a property value not including white space. Consider the following:</p>
<div class="fragment"><div class="line">font: 1em/1.5em &quot;Times New Roman&quot;, Times, serif;</div>
</div><!-- fragment --><p>The <code>PropertyName</code> is "font" and the <code>PropertyValue</code> represents everything after the colon. The parts are "1em" (dimension), "/" (operator), "1.5em" (dimension), "Times New Roman" (string), "," (operator), "Times" (identifier), "," (operator), and "serif" (identifier).</p>
<h2><a class="anchor" id="autotoc_md10644"></a>
Selectors</h2>
<p>The <code>parserlib.css.Selector</code> type represents a single selector. Each instance has a <code>parts</code> property, which is an array of <code>parserlib.css.SelectorPart</code> objects, which represent atomic parts of the selector, and <code>parserlib.css.Combinator</code> objects, which represent combinators in the selector. Consider the following selector:</p>
<div class="fragment"><div class="line">li.selected &gt; a:hover</div>
</div><!-- fragment --><p>This selector has three parts: <code>li.selected</code>, <code>&gt;</code>, and <code>a:hover</code>. The first part is a <code>SelectorPart</code>, the second is a <code>Combinator</code>, and the third is a <code>SelectorPart</code>. Each <code>SelectorPart</code> is made up of an optional element name followed by an ID, class, attribute condition, pseudo class, and/or pseudo element.</p>
<p>Each instance of <code>parserlib.css.SelectorPart</code> has an <code>elementName</code> property, which represents the element name as a <code>parserlib.css.SelectorSubPart</code> object or <code>null</code> if there isn't one, and a <code>modifiers</code> property, which is an array of <code>parserlib.css.SelectorSubPart</code> objects. Each <code>SelectorSubPart</code> object represents the smallest individual piece of a selector and has a <code>type</code> property indicating the type of subpart, "elementName", "class", "attribute", "pseudo", "id", "not". If the <code>type</code> is "not", then the <code>args</code> property contains an array of <code>SelectorPart</code> arguments that were passed to <code>not()</code>.</p>
<p>Each instance of <code>parserlib.css.Combinator</code> has an additional <code>type</code> property that indicates the type of combinator: "descendant", "child", "sibling", or "adjacent-sibling".</p>
<h1><a class="anchor" id="autotoc_md10645"></a>
Using events</h1>
<p>The CSS parser fires events as it parses text. The events correspond to important parts of the parsing algorithm and are designed to provide developers with all of the information necessary to create lint checkers, ASTs, and other data structures.</p>
<p>For many events, the <code>event</code> object contains additional information. This additional information is most frequently in the form of a <code>parserlib.util.SyntaxUnit</code> object, which has three properties:</p>
<ol type="1">
<li><code>text</code> - the string value</li>
<li><code>line</code> - the line on which this token appeared</li>
<li><code>col</code> - the column within the line at which this token appeared</li>
</ol>
<p>The <code>toString()</code> method for these objects is overridden to be the same value as <code>text</code>, so that you can treat the object as a string for comparison and concatenation purposes.</p>
<p>You should assign your event handlers before calling the <code>parse()</code> method.</p>
<h2><a class="anchor" id="autotoc_md10646"></a>
<code>startstylesheet</code> and <code>endstylesheet</code> events</h2>
<p>The <code>startstylesheet</code> event fires just before parsing of the CSS text begins and the <code>endstylesheet</code> event fires just after all of the CSS text has been parsed. There is no additional information provided for these events. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startstylesheet&quot;, function() {</div>
<div class="line">    console.log(&quot;Starting to parse stylesheet&quot;);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endstylesheet&quot;, function() {</div>
<div class="line">    console.log(&quot;Finished parsing stylesheet&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10647"></a>
<code>charset</code> event</h2>
<p>The <code>charset</code> event fires when the <code>@charset</code> directive is found in a stylesheet. Since <code>@charset</code> is required to appear first in a stylesheet, any other occurances cause a syntax error. The <code>charset</code> event provides an <code>event</code> object with a property called <code>charset</code>, which contains the name of the character set for the stylesheet. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;charset&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Character set is &quot; + event.charset);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10648"></a>
<code>namespace</code> event</h2>
<p>The <code>namespace</code> event fires when the <code>@namespace</code> directive is found in a stylesheet. The <code>namespace</code> event provides an <code>event</code> object with two properties: <code>prefix</code>, which is the namespace prefix, and <code>uri</code>, which is the namespace URI. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;namespace&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Namespace with prefix=&quot; + event.prefix + &quot; and URI=&quot; + event.uri);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10649"></a>
<code>import</code> event</h2>
<p>The <code>import</code> event fires when the <code>@import</code> directive is found in a stylesheet. The <code>import</code> event provides an <code>event</code> object with two properties: <code>uri</code>, which is the URI to import, and <code>media</code>, which is an array of media queries for which this URI applies. The <code>media</code> array contains zero or more <code>parserlib.css.MediaQuery</code> objects. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;import&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Importing &quot; + event.uri + &quot; for media types [&quot; + event.media + &quot;]&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10650"></a>
<code>startfontface</code> and <code>endfontface</code> events</h2>
<p>The <code>startfontface</code> event fires when <code>@font-face</code> is encountered and the <code>endfontface</code> event fires just after the closing right brace (<code>}</code>) is encountered after <code>@font-face</code>. There is no additional information available on the <code>event</code> object. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startfontface&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting font face&quot;);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endfontface&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending font face&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10651"></a>
<code>startpage</code> and <code>endpage</code> events</h2>
<p>The <code>startpage</code> event fires when <code>@page</code> is encountered and the <code>endpage</code> event fires just after the closing right brace (<code>}</code>) is encountered after <code>@page</code>. The <code>event</code> object has two properties: <code>id</code>, which is the page ID, and <code>pseudo</code>, which is the page pseudo class. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startpage&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting page with ID=&quot; + event.id + &quot; and pseudo=&quot; + event.pseudo);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endpage&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending page with ID=&quot; + event.id + &quot; and pseudo=&quot; + event.pseudo);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10652"></a>
<code>startpagemargin</code> and <code>endpagemargin</code> events</h2>
<p>The <code>startpagemargin</code> event fires when a page margin directive (such as <code>@top-left</code>) is encountered and the <code>endfontface</code> event fires just after the closing right brace (<code>}</code>) is encountered after the page margin. The <code>event</code> object has a <code>margin</code> property, which contains the actual page margin encountered. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startpagemargin&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting page margin &quot; + event.margin);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endpagemargin&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending page margin &quot; + event.margin);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10653"></a>
<code>startmedia</code> and <code>endmedia</code> events</h2>
<p>The <code>startmedia</code> event fires when <code>@media</code> is encountered and the <code>endmedia</code> event fires just after the closing right brace (<code>}</code>) is encountered after <code>@media</code>. The <code>event</code> object has one property, <code>media</code>, which is an array of <code>parserlib.css.MediaQuery</code> objects. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startpagemargin&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting page margin &quot; + event.margin);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endpagemargin&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending page margin &quot; + event.margin);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10654"></a>
<code>startkeyframes</code> and <code>endkeyframes</code> events</h2>
<p>The <code>startkeyframes</code> event fires when <code>@keyframes</code> (or any vendor prefixed version) is encountered and the <code>endkeyframes</code> event fires just after the closing right brace (<code>}</code>) is encountered after <code>@keyframes</code>. The <code>event</code> object has one property, <code>name</code>, which is the name of the animation. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startkeyframes&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting animation definition &quot; + event.name);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endkeyframes&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending animation definition &quot; + event.name);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10655"></a>
<code>startrule</code> and <code>endrule</code> events</h2>
<p>The <code>startrule</code> event fires just after all selectors on a rule have been parsed and the <code>endrule</code> event fires just after the closing right brace (<code>}</code>) is encountered for the rule. The <code>event</code> object has one additional property, <code>selectors</code>, which is an array of <code>parserlib.css.Selector</code> objects. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;startrule&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Starting rule with &quot; + event.selectors.length + &quot; selector(s)&quot;);</div>
<div class="line"> </div>
<div class="line">    for (var i = 0, len = event.selectors.length; i &lt; len; i++) {</div>
<div class="line">        var selector = event.selectors[i];</div>
<div class="line"> </div>
<div class="line">        console.log(&quot;  Selector #1 (&quot; + selector.line + &quot;,&quot; + selector.col + &quot;)&quot;);</div>
<div class="line"> </div>
<div class="line">        for (var j = 0, count=selector.parts.length; j &lt; count; j++) {</div>
<div class="line">            console.log(&quot;    Unit #&quot; + (j + 1));</div>
<div class="line"> </div>
<div class="line">            if (selector.parts[j] instanceof parserlib.css.SelectorPart) {</div>
<div class="line">                console.log(&quot;      Element name: &quot; + selector.parts[j].elementName);</div>
<div class="line"> </div>
<div class="line">                for (var k = 0; k &lt; selector.parts[j].modifiers.length; k++) {</div>
<div class="line">                    console.log(&quot;        Modifier: &quot; + selector.parts[j].modifiers[k]);</div>
<div class="line">                }</div>
<div class="line">            } else {</div>
<div class="line">                console.log(&quot;      Combinator: &quot; + selector.parts[j]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.addListener(&quot;endrule&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Ending rule with selectors [&quot; + event.selectors + &quot;]&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10656"></a>
<code>property</code> event</h2>
<p>The <code>property</code> event fires whenever a CSS property (<code>name:value</code>) is encountered, which may be inside of a rule, a media block, a page block, etc. The <code>event</code> object has four additional properties: <code>property</code>, which is the name of the property as a <code>parserlib.css.PropertyName</code> object, <code>value</code>, which is an instance of <code>parserlib.css.PropertyValue</code> (both types inherit from <code>parserlib.util.SyntaxUnit</code>), <code>important</code>, which is a Boolean value indicating if the property is flagged with <code>!important</code>, and <code>invalid</code> which is a Boolean value indicating whether the property value failed validation. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;property&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Property &#39;&quot; + event.property + &quot;&#39; has a value of &#39;&quot; + event.value + &quot;&#39; and &quot; + (event.important ? &quot;is&quot; : &quot;isn&#39;t&quot;) + &quot; important. (&quot; + event.property.line + &quot;,&quot; + event.property.col + &quot;)&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10657"></a>
<code>error</code> event</h2>
<p>The <code>error</code> event fires whenever a recoverable error occurs during parsing. When in strict mode, this event does not fire. The <code>event</code> object contains three additional properties: <code>message</code>, which is the error message, <code>line</code>, which is the line on which the error occurred, and <code>col</code>, which is the column on that line in which the error occurred. Example:</p>
<div class="fragment"><div class="line">parser.addListener(&quot;error&quot;, function(event) {</div>
<div class="line">    console.log(&quot;Parse error: &quot; + event.message + &quot; (&quot; + event.line + &quot;,&quot; + event.col + &quot;)&quot;, &quot;error&quot;);</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10658"></a>
Error recovery</h1>
<p>The CSS parser's goal is to be on-par with error recovery of CSS parsers in browsers. To that end, the following error recovery mechanisms are in place:</p>
<ul>
<li><b>Properties</b> - a syntactically incorrect property definition will be skipped over completely. For instance, the second property below is dropped:</li>
</ul>
<div class="fragment"><div class="line">a:hover {</div>
<div class="line">    color: red;</div>
<div class="line">    font:: Helvetica;   /* dropped! */</div>
<div class="line">    text-decoration: underline;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Selectors</b> - if there's a syntax error in <em>any</em> selector, the entire rule is skipped over. For instance, the following rule is completely skipped:</li>
</ul>
<div class="fragment"><div class="line">a:hover, foo ... bar {</div>
<div class="line">    color: red;</div>
<div class="line">    font: Helvetica;</div>
<div class="line">    text-decoration: underline;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>@ Rules</b> - there are certain @ rules that are only valid in certain contexts. The parser will skip over <code>@charset</code>, <code>@namespace</code>, and <code>@import</code> if they're found anywhere other than the beginning of the input.</li>
<li><b>Unknown @ Rules</b> - any @ rules that isn't recognized is automatically skipped, meaning the entire block after it is not parsed.</li>
</ul>
<h1><a class="anchor" id="autotoc_md10659"></a>
Running Tests</h1>
<p>You can run the tests via <code>npm test</code> from the repository's root. You may need to run <code>npm install</code> first to install the necessary dependencies. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
